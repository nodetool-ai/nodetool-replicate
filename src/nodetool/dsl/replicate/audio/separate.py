# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.replicate.audio.separate
from nodetool.workflows.base_node import BaseNode


class Demucs(SingleOutputGraphNode[typing.Any], GraphNode[typing.Any]):
    """
    Demucs is an audio source separator created by Facebook Research.
    """

    Stem: typing.ClassVar[type] = nodetool.nodes.replicate.audio.separate.Demucs.Stem
    Model: typing.ClassVar[type] = nodetool.nodes.replicate.audio.separate.Demucs.Model
    Clip_mode: typing.ClassVar[type] = (
        nodetool.nodes.replicate.audio.separate.Demucs.Clip_mode
    )
    Mp3_preset: typing.ClassVar[type] = (
        nodetool.nodes.replicate.audio.separate.Demucs.Mp3_preset
    )
    Wav_format: typing.ClassVar[type] = (
        nodetool.nodes.replicate.audio.separate.Demucs.Wav_format
    )
    Output_format: typing.ClassVar[type] = (
        nodetool.nodes.replicate.audio.separate.Demucs.Output_format
    )

    jobs: int | OutputHandle[int] = connect_field(
        default=0,
        description="Choose the number of parallel jobs to use for separation.",
    )
    stem: nodetool.nodes.replicate.audio.separate.Demucs.Stem = Field(
        default=nodetool.nodes.replicate.audio.separate.Demucs.Stem("none"),
        description="If you just want to isolate one stem, you can choose it here.",
    )
    audio: types.AudioRef | OutputHandle[types.AudioRef] = connect_field(
        default=types.AudioRef(
            type="audio", uri="", asset_id=None, data=None, metadata=None
        ),
        description="Upload the file to be processed here.",
    )
    model: nodetool.nodes.replicate.audio.separate.Demucs.Model = Field(
        default=nodetool.nodes.replicate.audio.separate.Demucs.Model("htdemucs"),
        description="Choose the demucs audio that proccesses your audio. The readme has more information on what to choose.",
    )
    split: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="Choose whether or not the audio should be split into chunks.",
    )
    shifts: int | OutputHandle[int] = connect_field(
        default=1,
        description="Choose the amount random shifts for equivariant stabilization. This performs multiple predictions with random shifts of the input and averages them, which makes it x times slower.",
    )
    overlap: float | OutputHandle[float] = connect_field(
        default=0.25,
        description="Choose the amount of overlap between prediction windows.",
    )
    segment: int | OutputHandle[int] | None = connect_field(
        default=None, description="Choose the segment length to use for separation."
    )
    clip_mode: nodetool.nodes.replicate.audio.separate.Demucs.Clip_mode = Field(
        default=nodetool.nodes.replicate.audio.separate.Demucs.Clip_mode("rescale"),
        description="Choose the strategy for avoiding clipping. Rescale will rescale entire signal if necessary or clamp will allow hard clipping.",
    )
    mp3_preset: nodetool.nodes.replicate.audio.separate.Demucs.Mp3_preset = Field(
        default=nodetool.nodes.replicate.audio.separate.Demucs.Mp3_preset(2),
        description="Choose the preset for the MP3 output. Higher is faster but worse quality. If MP3 is not selected as the output type, this has no effect.",
    )
    wav_format: nodetool.nodes.replicate.audio.separate.Demucs.Wav_format = Field(
        default=nodetool.nodes.replicate.audio.separate.Demucs.Wav_format("int24"),
        description="Choose format for the WAV output. If WAV is not selected as the output type, this has no effect.",
    )
    mp3_bitrate: int | OutputHandle[int] = connect_field(
        default=320,
        description="Choose the bitrate for the MP3 output. Higher is better quality but larger file size. If MP3 is not selected as the output type, this has no effect.",
    )
    output_format: nodetool.nodes.replicate.audio.separate.Demucs.Output_format = Field(
        default=nodetool.nodes.replicate.audio.separate.Demucs.Output_format("mp3"),
        description="Choose the audio format you would like the result to be returned in.",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.replicate.audio.separate.Demucs

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
