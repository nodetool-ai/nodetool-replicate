# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.replicate.image.enhance
from nodetool.workflows.base_node import BaseNode


class CodeFormer(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Robust face restoration algorithm for old photos/AI-generated faces
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(
            type="image", uri="", asset_id=None, data=None, metadata=None
        ),
        description="Input image",
    )
    upscale: int | OutputHandle[int] = connect_field(
        default=2, description="The final upsampling scale of the image"
    )
    face_upsample: bool | OutputHandle[bool] = connect_field(
        default=True,
        description="Upsample restored faces for high-resolution AI-created images",
    )
    background_enhance: bool | OutputHandle[bool] = connect_field(
        default=True, description="Enhance background image with Real-ESRGAN"
    )
    codeformer_fidelity: float | OutputHandle[float] = connect_field(
        default=0.5,
        description="Balance the quality (lower number) and fidelity (higher number).",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.replicate.image.enhance.CodeFormer

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.replicate.image.enhance
from nodetool.workflows.base_node import BaseNode


class Maxim(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Multi-Axis MLP for Image Processing
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(
            type="image", uri="", asset_id=None, data=None, metadata=None
        ),
        description="Input image.",
    )
    model: (
        nodetool.nodes.replicate.image.enhance.Maxim.Model
        | OutputHandle[nodetool.nodes.replicate.image.enhance.Maxim.Model]
        | None
    ) = connect_field(default=None, description="Choose a model.")

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.replicate.image.enhance.Maxim

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.replicate.image.enhance
from nodetool.workflows.base_node import BaseNode


class Night_Enhancement(
    SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]
):
    """
    Unsupervised Night Image Enhancement
    """

    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(
            type="image", uri="", asset_id=None, data=None, metadata=None
        ),
        description="Input image.",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.replicate.image.enhance.Night_Enhancement

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.replicate.image.enhance
from nodetool.workflows.base_node import BaseNode


class OldPhotosRestoration(
    SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]
):
    """
    Bringing Old Photos Back to Life
    """

    HR: bool | OutputHandle[bool] = connect_field(
        default=False, description="whether the input image is high-resolution"
    )
    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(
            type="image", uri="", asset_id=None, data=None, metadata=None
        ),
        description="input image.",
    )
    with_scratch: bool | OutputHandle[bool] = connect_field(
        default=False, description="whether the input image is scratched"
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.replicate.image.enhance.OldPhotosRestoration

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.replicate.image.enhance
from nodetool.workflows.base_node import BaseNode


class Supir_V0F(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Practicing Model Scaling for Photo-Realistic Image Restoration In the Wild. This is the SUPIR-v0F model and does NOT use LLaVA-13b.
    """

    Color_fix_type: typing.ClassVar[type] = (
        nodetool.nodes.replicate.image.enhance.Supir_V0F.Color_fix_type
    )

    seed: int | OutputHandle[int] | None = connect_field(
        default=None, description="Random seed. Leave blank to randomize the seed"
    )
    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(
            type="image", uri="", asset_id=None, data=None, metadata=None
        ),
        description="Low quality input image.",
    )
    s_cfg: float | OutputHandle[float] = connect_field(
        default=7.5, description=" Classifier-free guidance scale for prompts."
    )
    s_churn: float | OutputHandle[float] = connect_field(
        default=5, description="Original churn hy-param of EDM."
    )
    s_noise: float | OutputHandle[float] = connect_field(
        default=1.003, description="Original noise hy-param of EDM."
    )
    upscale: int | OutputHandle[int] = connect_field(
        default=1, description="Upsampling ratio of given inputs."
    )
    a_prompt: str | OutputHandle[str] = connect_field(
        default="Cinematic, High Contrast, highly detailed, taken using a Canon EOS R camera, hyper detailed photo - realistic maximum detail, 32k, Color Grading, ultra HD, extreme meticulous detailing, skin pore detailing, hyper sharpness, perfect without deformations.",
        description="Additive positive prompt for the inputs.",
    )
    min_size: float | OutputHandle[float] = connect_field(
        default=1024, description="Minimum resolution of output images."
    )
    n_prompt: str | OutputHandle[str] = connect_field(
        default="painting, oil painting, illustration, drawing, art, sketch, oil painting, cartoon, CG Style, 3D render, unreal engine, blurring, dirty, messy, worst quality, low quality, frames, watermark, signature, jpeg artifacts, deformed, lowres, over-smooth",
        description="Negative prompt for the inputs.",
    )
    s_stage1: int | OutputHandle[int] = connect_field(
        default=-1, description="Control Strength of Stage1 (negative means invalid)."
    )
    s_stage2: float | OutputHandle[float] = connect_field(
        default=1, description="Control Strength of Stage2."
    )
    edm_steps: int | OutputHandle[int] = connect_field(
        default=50, description="Number of steps for EDM Sampling Schedule."
    )
    linear_CFG: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Linearly (with sigma) increase CFG from 'spt_linear_CFG' to s_cfg.",
    )
    color_fix_type: nodetool.nodes.replicate.image.enhance.Supir_V0F.Color_fix_type = (
        Field(
            default=nodetool.nodes.replicate.image.enhance.Supir_V0F.Color_fix_type(
                "Wavelet"
            ),
            description="Color Fixing Type..",
        )
    )
    spt_linear_CFG: float | OutputHandle[float] = connect_field(
        default=1, description="Start point of linearly increasing CFG."
    )
    linear_s_stage2: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Linearly (with sigma) increase s_stage2 from 'spt_linear_s_stage2' to s_stage2.",
    )
    spt_linear_s_stage2: float | OutputHandle[float] = connect_field(
        default=0, description="Start point of linearly increasing s_stage2."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.replicate.image.enhance.Supir_V0F

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.replicate.image.enhance
from nodetool.workflows.base_node import BaseNode


class Supir_V0Q(SingleOutputGraphNode[types.ImageRef], GraphNode[types.ImageRef]):
    """
    Practicing Model Scaling for Photo-Realistic Image Restoration In the Wild. This is the SUPIR-v0Q model and does NOT use LLaVA-13b.
    """

    Color_fix_type: typing.ClassVar[type] = (
        nodetool.nodes.replicate.image.enhance.Supir_V0Q.Color_fix_type
    )

    seed: int | OutputHandle[int] | None = connect_field(
        default=None, description="Random seed. Leave blank to randomize the seed"
    )
    image: types.ImageRef | OutputHandle[types.ImageRef] = connect_field(
        default=types.ImageRef(
            type="image", uri="", asset_id=None, data=None, metadata=None
        ),
        description="Low quality input image.",
    )
    s_cfg: float | OutputHandle[float] = connect_field(
        default=7.5, description=" Classifier-free guidance scale for prompts."
    )
    s_churn: float | OutputHandle[float] = connect_field(
        default=5, description="Original churn hy-param of EDM."
    )
    s_noise: float | OutputHandle[float] = connect_field(
        default=1.003, description="Original noise hy-param of EDM."
    )
    upscale: int | OutputHandle[int] = connect_field(
        default=1, description="Upsampling ratio of given inputs."
    )
    a_prompt: str | OutputHandle[str] = connect_field(
        default="Cinematic, High Contrast, highly detailed, taken using a Canon EOS R camera, hyper detailed photo - realistic maximum detail, 32k, Color Grading, ultra HD, extreme meticulous detailing, skin pore detailing, hyper sharpness, perfect without deformations.",
        description="Additive positive prompt for the inputs.",
    )
    min_size: float | OutputHandle[float] = connect_field(
        default=1024, description="Minimum resolution of output images."
    )
    n_prompt: str | OutputHandle[str] = connect_field(
        default="painting, oil painting, illustration, drawing, art, sketch, oil painting, cartoon, CG Style, 3D render, unreal engine, blurring, dirty, messy, worst quality, low quality, frames, watermark, signature, jpeg artifacts, deformed, lowres, over-smooth",
        description="Negative prompt for the inputs.",
    )
    s_stage1: int | OutputHandle[int] = connect_field(
        default=-1, description="Control Strength of Stage1 (negative means invalid)."
    )
    s_stage2: float | OutputHandle[float] = connect_field(
        default=1, description="Control Strength of Stage2."
    )
    edm_steps: int | OutputHandle[int] = connect_field(
        default=50, description="Number of steps for EDM Sampling Schedule."
    )
    linear_CFG: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Linearly (with sigma) increase CFG from 'spt_linear_CFG' to s_cfg.",
    )
    color_fix_type: nodetool.nodes.replicate.image.enhance.Supir_V0Q.Color_fix_type = (
        Field(
            default=nodetool.nodes.replicate.image.enhance.Supir_V0Q.Color_fix_type(
                "Wavelet"
            ),
            description="Color Fixing Type..",
        )
    )
    spt_linear_CFG: float | OutputHandle[float] = connect_field(
        default=1, description="Start point of linearly increasing CFG."
    )
    linear_s_stage2: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Linearly (with sigma) increase s_stage2 from 'spt_linear_s_stage2' to s_stage2.",
    )
    spt_linear_s_stage2: float | OutputHandle[float] = connect_field(
        default=0, description="Start point of linearly increasing s_stage2."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.replicate.image.enhance.Supir_V0Q

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
